> 本教程介绍 CS61B 图章节中的拓扑排序

# 拓扑排序
考虑这样一个**有向无环图**：
![alt text](https://132-1331126615.cos.ap-guangzhou.myqcloud.com/TopoSort.png)
这其中的有效排序为有：
- [A,C,B,D,F,E,H,G]
- [C,A,D,F,B,E,G,H]
- ....

这个**顺序是按照箭头的指向**进行排序的，打个比方：你必须先学CS61A 才可以学CS61B,才可以学CS70....
我们的课程学习图就像这种有向无环图一样，必须遵循一定的顺序

## 算法流程
在一个有向无环图中，取一个结点，对其使用**深度优先算法**，然后对DFS算法**返回的顺序（后序）进行倒序**，即可得到拓扑排序的结果，如果结点用完了，必须重新启动DFS（始终从**入度为0的结点**开始）

浅显的解释：
DFS先从**较浅的结点开始，然后逐渐深入**，比如从A到H，**后序将首先列出较深的结点，然后再列出较浅的结点**

比如我们在上面给出的图中，从A开始进行DFS
- 在一个 list 中记录下DFS：[H,E,B,D,A,G,F,C]
- 然后对这个 list 进行逆序：[C,F,G,A,D,B,E,H]

# 为什么这被称作排序呢？
对于上面这个图如果我们把他进行一些拖拽处理，会发现：
![alt text](https://132-1331126615.cos.ap-guangzhou.myqcloud.com/Toposort1.png)
会发现这个图变成一个所**有箭头都指向右边的带有某种顺序的图**，这就是我们**“做事”的顺序**

# 如果有环怎么办？
事实上，如果有环，拓扑排序会告诉你：oh,no,我不能处理有环的情况，**结果就是——没有答案**，这是一个未定义的的问题
所以拓扑排序只适用于**有向无环图**（directed acyclic graph, DAG）

# 如果边权重有负数呢？
答案是：拓扑排序**仍然可以得到正确的结果**，这一点可比Dijkstra 算法要好多啦！

# 拓扑排序有什么用呢？
## Dijkstra 在负权重下的失效
我们知道Dijkstra算法会在**负数权重边的情况下失败**，这是因为，Dijkstra算法默认所有边的权重都为正数，这样**后访问的节点的距离一定大于先访问的节点的距离**
所以我们遇见**之后relax出来的边指向已经访问过的结点**的时候，我们知道一定不是更优解，但是负数权重打破了这一结论
比如下面这个情况：
![alt text](https://132-1331126615.cos.ap-guangzhou.myqcloud.com/negativeWeight.png)
我们在访问c节点并relax之前，已经访问过了E节点，根据Dijkstra 算法，我们直接不考虑C->E这条边，但是这里显然因为这条边是负权重，所以这是一条更优解，Dijkstra算法在这里就失效了。

## 拓扑排序在负权重的应用
首先这只适用于 **有向无环图**，因为在这种情况下拓扑排序才能生效
现在我们不再采用Dijkstra算法的最佳优先顺序了，我们**采用拓扑排序生成的从左到右的顺序**
![alt text](https://132-1331126615.cos.ap-guangzhou.myqcloud.com/TopoSort2.png)
现在我们的fringe没有所谓的优先级了，我们直**接按照从左到右的顺序进行访问和relax**
### 算法流程如下
1. 访问A节点
   1. A->D, distTo[D] = 1, edgeTo[D] = A
   2. A->B, distTo[B] = 1, edgeTo[B] = A
2. 访问D节点
   1. D->B, distTo[D] + 1 > distTo[B] 不改变
   2. D->E, distTo[E] = distTo[D] + 1 = 2, edgeTo[E] = D
3. 访问B
4. ...
5. 访问C 
   1. C->E, distTo[C] - 20 < distTo[E],distTo[E] = -13, edgeTo[E] = D
   2. C->F, dist[F] = 8
6. ...

## 为什么拓扑排序在负权重可以有用？
因为我们的访问顺序按照拓扑排序，这样**每个访问的节点relax的边永远不会指向已经访问过的节点**（所有的边都遵循“从左向右指向”）

# 最长路径问题
现在我们考虑这样一个问题：如何找到一个图中的最长路径呢？
一个非常惊人的事实是：
- 已知的最高效的算法都是**指数级的时间复杂度**

我们把问题想得简单一点，现在只考虑有向无环图
我们可以做这样的转换：
- **求最长路径，实际上就是求负数的最短路径**

在这个基础上，我们**把所有边变成相反数，然后把他扔给最短路径算法，最后再翻转回来即可！！**

这个过程我们称为“规约”(reduction).
下面就是我们的这个过程：我们先做一个预处理，得出结果后，再做反处理就可以得到我们想要的结果，有时候我们**只用考虑 Preprocess 和 Postprocess 的过程**，因为有可能中间的这些困难的问题我们已经解决了！
![alt text](https://132-1331126615.cos.ap-guangzhou.myqcloud.com/reduction.png)